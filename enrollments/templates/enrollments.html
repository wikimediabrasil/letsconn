{% load custom_filters %}
<!DOCTYPE html>
<html>
    <head>
        <title>Enrollments</title>
        <style>
            body {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                font-family: Arial, sans-serif;
                background-color: #f4f4f4;
            }
            img {
                max-width: 300px;
                height: auto;
                margin-bottom: 20px;
            }
            .table-container {
                width: 80%;
                max-height: 70vh;
                overflow-y: auto;
                background-color: #fff;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            }
            .button-container {
                display: flex;
                gap: 10px;
                justify-content: center;
                margin: 20px;
            }
            button {
                padding: 10px 20px;
                font-size: 16px;
                color: #fff;
                background-color: #007bff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }
            button:hover {
                background-color: #0056b3;
            }
            button.csv {
                background-color: #28a745;
            }
            button.csv:hover {
                background-color: #218838;
            }
            button.load {
                background-color: #6f42c1;
            }
            button.load:hover {
                background-color: #5a32a3;
            }
        </style>
        <style>
            /* Basic table styles and sort indicators */
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; }
            th { cursor: pointer; position: sticky; top: 0; background: #fafafa; }
            th.sort-asc::after { content: " \25B2"; }
            th.sort-desc::after { content: " \25BC"; }
            #filterInput { width: 300px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }

            /* Hide extra columns until user data is loaded */
            #myTable .extra-col { display: none; }
            #myTable.show-extra .extra-col { display: table-cell; }

            /* Column visibility */
            .hidden-cell { display: none !important; }
            .column-panel { display: none; width: 80%; max-width: 1000px; background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px; }
            .column-panel.show { display: block; }
            .column-list { column-width: 240px; column-gap: 16px; max-height: 40vh; overflow: auto; }
            .column-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
            .column-actions button, .column-actions label { margin: 4px 0; }
        </style>
        <style>
            .loader {
                border: 16px solid #f3f3f3;
                border-radius: 50%;
                border-top: 16px solid #000000;
                width: 120px;
                height: 120px;
                margin: auto;
                animation: spin 2s linear infinite;
                display: none;
            }
        
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        
            #myTable { font-size: small; }
        </style>
    </head>
    <body>
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Let%27s_Connect_logo.svg/300px-Let%27s_Connect_logo.svg.png" alt="Let's Connect Logo">
        <div class="button-container">
            <button class="csv" id="downloadCsvBtn">Download CSV</button>
            <button onclick="window.location.href='/'">Home</button>
            <button class="load" id="loadUserDataBtn">Load User Data</button>
        </div>
        <div class="button-container">
            <input id="filterInput" type="text" placeholder="Type to filter rows..." />
            <button id="toggleColumnPanel">Columns</button>
            <button id="fitToScreenBtn">Fit to screen</button>
        </div>
        <div id="columnPanel" class="column-panel">
            <div class="column-actions">
                <button id="showAllCols" type="button">Show all</button>
                <button id="hideAllCols" type="button">Hide all</button>
                <label><input type="checkbox" id="autoFitOnLoad" /> Auto-fit on load</label>
            </div>
            <div id="columnList" class="column-list"></div>
        </div>
        <div class="loader" id="loader"></div>
        <div class="table-container">
            <table id="myTable" class="display responsive" style="width:100%">
                <thead>
                    <tr>
                        {% with all_keys=all_enrollment_keys %}
                            {% for key in all_keys %}
                                <th>{{ key|capfirst|underscore }}</th>
                            {% endfor %}
                        {% endwith %}
                        <th>Enrollment time</th>
                        <th class="extra-col">Territory</th>
                        <th class="extra-col">Affiliation</th>
                        <th class="extra-col">Language</th>
                        <th class="extra-col">Manager</th>
                        <th class="extra-col">Alternative Wikimedia account</th>
                        <th class="extra-col">Wikimedia projects</th>
                        <th class="extra-col">Available capacities</th>
                        <th class="extra-col">Known capacities</th>
                        <th class="extra-col">Wanted capacities</th>
                        <th class="extra-col">Badges</th>
                        <th class="extra-col">Joined Date</th>
                        <th class="extra-col">Last Update</th>
                        <th class="extra-col">Last Login</th>
                    </tr>
                </thead>
                <tbody>
                    {% for enrollment in enrollments %}
                        <tr>
                            {% with all_keys=all_enrollment_keys %}
                                {% for key in all_keys %}
                                    <td>{{ enrollment.data|get_item:key }}</td>
                                {% endfor %}
                            {% endwith %}
                            <td>{{ enrollment.timestamp }}</td>
                            <td class="territory extra-col"></td>
                            <td class="affiliation extra-col"></td>
                            <td class="language extra-col"></td>
                            <td class="manager extra-col"></td>
                            <td class="alternative-wikimedia-account extra-col"></td>
                            <td class="wikimedia-projects extra-col"></td>
                            <td class="available-capacities extra-col"></td>
                            <td class="known-capacities extra-col"></td>
                            <td class="wanted-capacities extra-col"></td>
                            <td class="badges extra-col"></td>
                            <td class="joined-date extra-col"></td>
                            <td class="last-update extra-col"></td>
                            <td class="last-login extra-col"></td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        <div class="status" id="status"></div>
        <script type="text/javascript">
            // Utilities
            function getCookie(name) {
                let cookieValue = null;
                if (document.cookie && document.cookie !== '') {
                    const cookies = document.cookie.split(';');
                    for (let i = 0; i < cookies.length; i++) {
                        const cookie = cookies[i].trim();
                        if (cookie.substring(0, name.length + 1) === (name + '=')) {
                            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                            break;
                        }
                    }
                }
                return cookieValue;
            }

            const csrftoken = getCookie('csrftoken');
            const serverName = window.location.origin;

            document.addEventListener('DOMContentLoaded', function() {
                const table = document.getElementById('myTable');
                const thead = table.tHead;
                const tbody = table.tBodies[0];
                const loader = document.getElementById('loader');
                const statusBox = document.getElementById('status');
                const filterInput = document.getElementById('filterInput');
                const columnPanel = document.getElementById('columnPanel');
                const toggleColumnPanelBtn = document.getElementById('toggleColumnPanel');
                const columnList = document.getElementById('columnList');
                const showAllColsBtn = document.getElementById('showAllCols');
                const hideAllColsBtn = document.getElementById('hideAllCols');
                const fitToScreenBtn = document.getElementById('fitToScreenBtn');
                const autoFitOnLoad = document.getElementById('autoFitOnLoad');

                // Sort helpers
                function getCellSortValue(cell) {
                    const ds = cell.getAttribute('data-sort');
                    if (ds !== null) {
                        const n = Number(ds);
                        return isNaN(n) ? ds : n;
                    }
                    const txt = cell.textContent.trim();
                    const num = Number(txt.replace(/,/g, ''));
                    if (!isNaN(num) && txt !== '') return num;
                    const dt = Date.parse(txt);
                    if (!isNaN(dt)) return dt;
                    return txt.toLowerCase();
                }

                function clearSortIndicators() {
                    Array.from(thead.rows[0].cells).forEach(th => {
                        th.classList.remove('sort-asc', 'sort-desc');
                    });
                }

                function sortTableByColumn(index, asc = true) {
                    const rows = Array.from(tbody.rows);
                    rows.sort((a, b) => {
                        const av = getCellSortValue(a.cells[index] || { textContent: '' });
                        const bv = getCellSortValue(b.cells[index] || { textContent: '' });
                        if (av < bv) return asc ? -1 : 1;
                        if (av > bv) return asc ? 1 : -1;
                        return 0;
                    });
                    rows.forEach(r => tbody.appendChild(r));
                }

                // Attach click sort on headers
                Array.from(thead.rows[0].cells).forEach((th, idx) => {
                    th.addEventListener('click', () => {
                        const asc = !th.classList.contains('sort-asc');
                        clearSortIndicators();
                        sortTableByColumn(idx, asc);
                        th.classList.add(asc ? 'sort-asc' : 'sort-desc');
                    });
                });

                // Filter by text across all cells
                function filterRows(query) {
                    const q = query.toLowerCase();
                    Array.from(tbody.rows).forEach(tr => {
                        const text = Array.from(tr.cells).map(td => td.textContent).join(' ').toLowerCase();
                        tr.style.display = text.includes(q) ? '' : 'none';
                    });
                }
                filterInput.addEventListener('input', (e) => filterRows(e.target.value));

                // Helper to fetch lists
                async function fetchList(type) {
                    const response = await fetch(`${serverName}/proxy/?item=${type}`);
                    return response.json();
                }

                // Determine username column index (prefer header "username")
                function findUsernameColIndex() {
                    const headers = Array.from(thead.rows[0].cells).map(th => th.textContent.trim().toLowerCase());
                    let idx = headers.findIndex(h => h === 'username' || h.includes('user name'));
                    if (idx === -1) idx = 0; // fallback to first column
                    return idx;
                }

                document.getElementById('loadUserDataBtn').addEventListener('click', async () => {
                    loader.style.display = 'block';
                    statusBox.innerHTML = '<div style="text-align:center;">Starting user data fetch...</div>';
                    document.querySelector('.table-container').style.display = 'none';

                    const userCache = {};
                    const usernameIdx = findUsernameColIndex();
                    const usernamesSet = Array.from(tbody.rows).map(r => (r.cells[usernameIdx]?.textContent || '').trim());
                    const usernames = [...new Set(usernamesSet.filter(u => u !== ''))];

                    // Fetch all valid users first
                    const validUsersResp = await fetch(`${serverName}/proxy/?item=users`);
                    const validUsersData = await validUsersResp.json();
                    const validUsernames = new Set(Object.values(validUsersData));
                    const filteredUsernames = usernames.filter(u => validUsernames.has(u));

                    const [territoryData, affiliationData, wikimediaProjectsData, capacityData, badgesData, languageData] = await Promise.all([
                        fetchList('territory'),
                        fetchList('affiliation'),
                        fetchList('wikimedia_project'),
                        fetchList('skills'),
                        fetchList('badges'),
                        fetchList('language')
                    ]);

                    function getTerritoryNames(user) {
                        return (user.territory || []).map(id => territoryData[id] || 'Unknown').join(', ');
                    }
                    function getAffiliationNames(user) {
                        return (user.affiliation || []).map(id => affiliationData[id] || 'Unknown').join(', ');
                    }
                    function getManagerNames(user) {
                        return (user.is_manager || []).map(id => affiliationData[id] || 'Unknown').join(', ');
                    }
                    function getWikimediaProjectNames(user) {
                        return (user.wikimedia_projects || []).map(id => wikimediaProjectsData[id] || 'Unknown').join(', ');
                    }
                    function getBadgesNames(user) {
                        return (user.badges || []).map(id => badgesData[id] || 'Unknown').join(', ');
                    }
                    function getLanguageNames(user) {
                        return (user.language || []).map(lang => {
                            const name = languageData[lang.id] || 'Unknown';
                            return `${name} (${lang.proficiency || '?'})`;
                        }).join(', ');
                    }

                    const allCapacityQIDs = new Set();
                    function getWantedCapacities(user) {
                        const qids = user.skills_wanted || [];
                        qids.forEach(id => allCapacityQIDs.add(capacityData[id]));
                        return qids.map(id => capacityData[id] || 'Unknown').join(', ');
                    }
                    function getAvailableCapacities(user) {
                        const qids = user.skills_available || [];
                        qids.forEach(id => allCapacityQIDs.add(capacityData[id]));
                        return qids.map(id => capacityData[id] || 'Unknown').join(', ');
                    }
                    function getKnownCapacities(user) {
                        const qids = user.skills_known || [];
                        qids.forEach(id => allCapacityQIDs.add(capacityData[id]));
                        return qids.map(id => capacityData[id] || 'Unknown').join(', ');
                    }

                    function changeQidToName(qid) {
                        if (!qid) return 'Unknown';
                        let qidNames = [];
                        const qids = qid.split(',').map(q => q.trim());
                        for (const q of qids) {
                            const name = capacityData[q] || 'Unknown';
                            qidNames.push(name);
                        }
                        return qidNames.join(', ');
                    }

                    for (let i = 0; i < filteredUsernames.length; i++) {
                        const username = filteredUsernames[i];
                        statusBox.innerHTML = `<div style="text-align:center;">Getting data from user ${i + 1} of ${filteredUsernames.length}<br><b>${username}</b></div>`;
                        try {
                            const response = await fetch(`${serverName}/proxy/?query=user__username=${encodeURIComponent(username)}`);
                            const data = await response.json();
                            if (data.results && data.results.length > 0) {
                                const user = data.results[0];
                                const joinedDate = new Date(user.user.date_joined);
                                const lastUpdate = new Date(user.last_update);
                                const lastLogin = new Date(user.last_login);
                                userCache[username] = {
                                    joinedDateText: joinedDate.toLocaleString(),
                                    lastUpdateText: lastUpdate.toLocaleString(),
                                    lastLoginText: lastLogin.toLocaleString(),
                                    joinedDateTs: joinedDate.getTime(),
                                    lastUpdateTs: lastUpdate.getTime(),
                                    lastLoginTs: lastLogin.getTime(),
                                    territory: getTerritoryNames(user),
                                    affiliation: getAffiliationNames(user),
                                    manager: getManagerNames(user),
                                    language: getLanguageNames(user),
                                    wikimediaProjects: getWikimediaProjectNames(user),
                                    wantedCapacities: getWantedCapacities(user),
                                    availableCapacities: getAvailableCapacities(user),
                                    knownCapacities: getKnownCapacities(user),
                                    badges: getBadgesNames(user)
                                };
                            } else {
                                userCache[username] = {
                                    joinedDateText: '', lastUpdateText: '', lastLoginText: '',
                                    joinedDateTs: '', lastUpdateTs: '', lastLoginTs: '',
                                    territory: '', affiliation: '', manager: '', language: '', wikimediaProjects: '',
                                    wantedCapacities: '', availableCapacities: '', knownCapacities: '', badges: ''
                                };
                            }
                        } catch (error) {
                            console.error(`Error fetching data for ${username}:`, error);
                            userCache[username] = {
                                joinedDateText: '', lastUpdateText: '', lastLoginText: '',
                                joinedDateTs: '', lastUpdateTs: '', lastLoginTs: '',
                                territory: '', affiliation: '', manager: '', language: '', wikimediaProjects: '',
                                wantedCapacities: '', availableCapacities: '', knownCapacities: '', badges: ''
                            };
                        }
                    }
                    statusBox.innerHTML = '';

                    // Convert all QIDs to real names via POST request
                    const qidArray = Array.from(allCapacityQIDs);
                    if (qidArray.length) {
                        const qidResponse = await fetch(`${serverName}/proxy/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrftoken
                            },
                            body: JSON.stringify({ qids: qidArray })
                        });
                        const qidData = await qidResponse.json();
                        qidArray.forEach(qid => {
                            const matchingItem = qidData.find(item => item.wd_code === qid);
                            if (matchingItem) {
                                capacityData[qid] = matchingItem.name;
                            }
                        });
                    }

                    // Update DOM rows
                    Array.from(tbody.rows).forEach(tr => {
                        const username = (tr.cells[usernameIdx]?.textContent || '').trim();
                        const userData = userCache[username] || {
                            joinedDateText: '', lastUpdateText: '', lastLoginText: '',
                            joinedDateTs: '', lastUpdateTs: '', lastLoginTs: '',
                            territory: '', affiliation: '', manager: '', language: '', wikimediaProjects: '',
                            wantedCapacities: '', availableCapacities: '', knownCapacities: '', badges: ''
                        };
                        const setCell = (selector, text, sortVal) => {
                            const cell = tr.querySelector(selector);
                            if (cell) {
                                cell.textContent = text || '';
                                if (sortVal !== undefined && sortVal !== null && sortVal !== '') {
                                    cell.setAttribute('data-sort', String(sortVal));
                                }
                            }
                        };
                        setCell('.joined-date', userData.joinedDateText, userData.joinedDateTs);
                        setCell('.last-update', userData.lastUpdateText, userData.lastUpdateTs);
                        setCell('.last-login', userData.lastLoginText, userData.lastLoginTs);
                        setCell('.territory', userData.territory);
                        setCell('.affiliation', userData.affiliation);
                        setCell('.language', userData.language);
                        setCell('.manager', userData.manager);
                        setCell('.wikimedia-projects', userData.wikimediaProjects);
                        setCell('.wanted-capacities', changeQidToName(userData.wantedCapacities));
                        setCell('.available-capacities', changeQidToName(userData.availableCapacities));
                        setCell('.known-capacities', changeQidToName(userData.knownCapacities));
                        setCell('.badges', userData.badges);
                    });

                    // Show table and reveal extra columns
                    loader.style.display = 'none';
                    document.querySelector('.table-container').style.display = 'block';
                    table.classList.add('show-extra');
                        afterRevealExtraColumns();
                });

                // CSV download (no DataTables)
                document.getElementById('downloadCsvBtn').addEventListener('click', function() {
                    const rows = [];
                    rows.push(['SEP=,']);
                    const visibleIdx = visibleColumnIndexes();
                    const headers = visibleIdx.map(i => thead.rows[0].cells[i]).map(th => `"${th.textContent.trim().replace(/"/g, '""')}"`);
                    rows.push(headers);
                    Array.from(tbody.rows).forEach(tr => {
                        const cols = visibleIdx.map(i => tr.cells[i]).map(td => `"${(td && td.textContent ? td.textContent.trim().replace(/"/g, '""') : '')}"`);
                        rows.push(cols);
                    });
                    const csvContent = rows.map(r => r.join(',')).join('\n');
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', 'enrollment_data.csv');
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });

                // ----- Column visibility management -----
                const LS_KEY = 'enrollments_visible_columns_v1';

                function allColumnHeaders() {
                    return Array.from(thead.rows[0].cells).map((th, idx) => ({
                        idx,
                        title: th.textContent.trim(),
                    }));
                }

                function applyVisibilityFromState(state) {
                    const headers = thead.rows[0].cells;
                    const rows = Array.from(tbody.rows);
                    state.forEach((visible, idx) => {
                        const show = !!visible;
                        const th = headers[idx];
                        if (!th) return;
                        th.classList.toggle('hidden-cell', !show);
                        rows.forEach(tr => {
                            const td = tr.cells[idx];
                            if (td) td.classList.toggle('hidden-cell', !show);
                        });
                    });
                }

                function visibleColumnIndexes() {
                    const headers = thead.rows[0].cells;
                    return Array.from(headers).reduce((acc, th, idx) => {
                        if (!th.classList.contains('hidden-cell')) acc.push(idx);
                        return acc;
                    }, []);
                }

                function buildColumnPanel(state) {
                    columnList.innerHTML = '';
                    const headers = allColumnHeaders();
                    headers.forEach(h => {
                        const id = `col-vis-${h.idx}`;
                        const wrapper = document.createElement('div');
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.id = id;
                        cb.checked = state[h.idx] !== false; // default visible unless explicitly false
                        cb.addEventListener('change', () => {
                            state[h.idx] = cb.checked;
                            saveState(state);
                            applyVisibilityFromState(state);
                        });
                        const label = document.createElement('label');
                        label.setAttribute('for', id);
                        label.textContent = h.title || `Column ${h.idx + 1}`;
                        wrapper.appendChild(cb);
                        wrapper.appendChild(label);
                        columnList.appendChild(wrapper);
                    });
                }

                function saveState(state) {
                    localStorage.setItem(LS_KEY, JSON.stringify({
                        visible: state,
                        autoFit: !!autoFitOnLoad.checked
                    }));
                }

                function loadState() {
                    try {
                        const raw = localStorage.getItem(LS_KEY);
                        if (!raw) return null;
                        const parsed = JSON.parse(raw);
                        if (!Array.isArray(parsed.visible)) return null;
                        autoFitOnLoad.checked = !!parsed.autoFit;
                        return parsed.visible;
                    } catch (e) {
                        console.warn('Failed to parse visibility state', e);
                        return null;
                    }
                }

                function defaultVisibilityState() {
                    // Show as many columns as fit initially (heuristic: at least 5, prefer 10 or fewer)
                    const count = thead.rows[0].cells.length;
                    const base = new Array(count).fill(true);
                    // Hide the extra columns by default until user data loads, consistent with existing classes
                    Array.from(thead.rows[0].cells).forEach((th, idx) => {
                        if (th.classList.contains('extra-col')) base[idx] = false;
                    });
                    return base;
                }

                // Initialize state
                let visState = loadState() || defaultVisibilityState();
                applyVisibilityFromState(visState);
                buildColumnPanel(visState);

                toggleColumnPanelBtn.addEventListener('click', () => {
                    columnPanel.classList.toggle('show');
                });
                showAllColsBtn.addEventListener('click', () => {
                    visState = new Array(thead.rows[0].cells.length).fill(true);
                    saveState(visState);
                    applyVisibilityFromState(visState);
                    buildColumnPanel(visState);
                });
                hideAllColsBtn.addEventListener('click', () => {
                    // Keep at least first column visible for context
                    visState = new Array(thead.rows[0].cells.length).fill(false);
                    visState[0] = true;
                    saveState(visState);
                    applyVisibilityFromState(visState);
                    buildColumnPanel(visState);
                });
                autoFitOnLoad.addEventListener('change', () => saveState(visState));

                // Auto-fit algorithm: measure table width and hide columns from the end until it fits
                function autoFitColumns(preferKeep = []) {
                    // Reset to state visibility first
                    applyVisibilityFromState(visState);

                    const container = document.querySelector('.table-container');
                    const maxWidth = container.clientWidth - 24; // padding allowance
                    const headers = thead.rows[0].cells;

                    const getWidth = () => table.scrollWidth;
                    const fits = () => getWidth() <= maxWidth;

                    // Determine candidate columns to hide (excluding preferKeep by index)
                    const candidates = Array.from(headers).map((_, i) => i).filter(i => visState[i] !== false && !preferKeep.includes(i));

                    // If already fits, nothing to do
                    if (fits()) return;

                    // Hide from the end first, then from the middle if needed
                    const order = candidates.slice().reverse();
                    for (const idx of order) {
                        visState[idx] = false;
                        applyVisibilityFromState(visState);
                        if (fits()) break;
                    }
                    saveState(visState);
                    buildColumnPanel(visState);
                }

                fitToScreenBtn.addEventListener('click', () => {
                    // Keep first few columns visible if possible: username + key fields
                    const keep = [0];
                    autoFitColumns(keep);
                });

                window.addEventListener('resize', () => {
                    if (autoFitOnLoad.checked) {
                        // Re-apply vis state then auto-fit
                        applyVisibilityFromState(visState);
                        autoFitColumns([0]);
                    }
                });

                // When user data is loaded and extra columns are shown, optionally auto-fit
                function afterRevealExtraColumns() {
                    // Update default vis state for newly revealed extra columns if state doesn't cover them
                    const count = thead.rows[0].cells.length;
                    if (visState.length < count) {
                        const add = new Array(count - visState.length).fill(true);
                        visState = visState.concat(add);
                    }
                    saveState(visState);
                    applyVisibilityFromState(visState);
                    buildColumnPanel(visState);
                    if (autoFitOnLoad.checked) {
                        autoFitColumns([0]);
                    }
                }
            });
        </script>
    </body>
</html>